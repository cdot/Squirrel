{"version":3,"sources":["js/AES.js"],"names":["AES","encrypt","ab","password","nBits","plaintext","Uint8Array","nBytes","pwBytes","Array","i","length","charCodeAt","key","Aes","cipher","keyExpansion","concat","slice","counterBlock","size","nonce","Date","now","nonceMs","nonceSec","nonceRnd","Math","random","keySchedule","blockCount","ceil","ciphertxt","b","c","cipherCntr","blockLength","cipherChar","ct","set","offset","decrypt","ciphertext","nBlocks","subarray","plaintxt","blen","plaintxtByte","pt"],"mappings":"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","file":"js/AES.min.js","sourcesContent":["/*@preserve Copyright (C) 2015 Crawford Currie http://c-dot.co.uk license MIT*/\n\n/* eslint-env browser */\n\n/* global Aes */\n/* global Uint8Array */\n\n/**\n * AES Counter-mode implementation in JavaScript\n * Based on Chris Veness' work (C) 2005-2014 Chris Veness / MIT Licence\n *\n * See http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf\n *\n * @augments Aes\n */\nvar AES = {};\n\n/**\n * Encrypt an ArrayBuffer using AES in Counter mode.\n *\n * @param   {ArrayBuffer} ab Source to be encrypted.\n * @param   {String} password The password to use to generate a key.\n * @param   {number} nBits Number of bits to be used in the key;\n * 128 / 192 / 256.\n * @returns {Uint8Array} Encrypted data\n */\nAES.encrypt = function(ab, password, nBits) {\n    \"use strict\";\n\n    // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\n    var blockSize = 16;\n\n    var plaintext = new Uint8Array(ab);\n\n    // use AES itself to encrypt password to get cipher key (using\n    // plain password as source for key expansion) - gives us well\n    // encrypted key (though hashed key might be preferred for prod'n use)\n    var nBytes = nBits / 8;  // no bytes in key (16/24/32)\n    var pwBytes = new Array(nBytes);\n\n    // use 1st 16/24/32 chars of password for key, zero padded\n    for (var i = 0; i < nBytes; i++) {\n        if (i < password.length)\n            pwBytes[i] = password.charCodeAt(i) & 255;\n        else\n            pwBytes[i] = 0;\n    }\n\n    // get 16-byte key\n    var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n\n    // expand key to 16/24/32 bytes long\n    key = key.concat(key.slice(0, nBytes - 16));\n\n    // initialise 1st 8 bytes of counter block with nonce\n    // (NIST SP800-38A Â§B.2): [0-1] = millisec,\n    // [2-3] = random, [4-7] = seconds, together giving full sub-millisec\n    // uniqueness up to Feb 2106\n    var counterBlock = new Uint8Array(8);\n    var size = 8;\n\n    // timestamp: milliseconds since 1-Jan-1970\n    var nonce = Date.now();\n    var nonceMs = nonce % 1000;\n    var nonceSec = (nonce / 1000) >> 0;\n    var nonceRnd = (Math.random() * 0xffff) >> 0;\n    // for debugging: nonce = nonceMs = nonceSec = nonceRnd = 0;\n\n    for (i = 0; i < 2; i++)\n        counterBlock[i] = (nonceMs >>> i * 8) & 0xff;\n    for (i = 0; i < 2; i++)\n        counterBlock[i + 2] = (nonceRnd >>> i * 8) & 0xff;\n    for (i = 0; i < 4; i++)\n        counterBlock[i + 4] = (nonceSec >>> i * 8) & 0xff;\n\n    // generate key schedule - an expansion of the key into distinct\n    // Key Rounds for each round\n    var keySchedule = Aes.keyExpansion(key);\n\n    var blockCount = Math.ceil(plaintext.length / blockSize);\n\n    // Ciphertext as an array of Uint8Array\n    var ciphertxt = new Array(blockCount);\n\n    for (var b = 0; b < blockCount; b++) {\n        // set counter (block #) in last 8 bytes of counter block\n        // (leaving nonce in 1st 8 bytes). Done in two stages for\n        // 32-bit ops: using two words allows us to go past 2^32 blocks (68GB)\n        for (var c = 0; c < 4; c++)\n            counterBlock[15 - c] = (b >>> c * 8) & 0xff;\n        for (c = 0; c < 4; c++)\n            counterBlock[15 - c - 4] = (b / 0x100000000 >>> c * 8);\n\n        // encrypt counter block\n        var cipherCntr = Aes.cipher(counterBlock, keySchedule); \n\n        // block size is reduced on final block\n        var blockLength = b < blockCount - 1\n            ? blockSize : (plaintext.length - 1) % blockSize + 1;\n        var cipherChar = new Uint8Array(blockLength);\n        size += blockLength;\n\n        // xor plaintext with ciphered counter char-by-char\n        for (i = 0; i < blockLength; i++) {\n            if (cipherCntr[i] > 255) debugger;\n            cipherChar[i] = cipherCntr[i] ^ plaintext[b * blockSize + i];\n        }\n        ciphertxt[b] = cipherChar;\n    }\n\n    var ct = new Uint8Array(size);\n    ct.set(counterBlock);\n    var offset = counterBlock.length;\n    for (b = 0; b < blockCount; b++) {\n        ct.set(ciphertxt[b], offset);\n        offset += ciphertxt[b].length;\n    }\n    return ct;\n};\n\n\n/**\n * Decrypt an ArrayBuffer using AES in counter mode\n *\n * @param   {ArrayBuffer} ab Source to be dencrypted.\n * @param   {String} password The password to use to generate a key.\n * @param   {number} nBits Number of bits to be used in the key;\n * 128 / 192 / 256.\n * @returns {ArrayBuffer} Encrypted data\n * @returns {ArrayBuffer} Decrypted data\n */\nAES.decrypt = function(ab, password, nBits) {\n    \"use strict\";\n\n    var blockSize = 16;\n\n    var ciphertext = new Uint8Array(ab);\n\n    // use AES to encrypt password (mirroring encrypt routine)\n    var nBytes = nBits / 8;  // no bytes in key\n    var pwBytes = new Uint8Array(nBytes);\n    for (var i = 0; i < nBytes; i++) {\n        if (i < password.length)\n            pwBytes[i] = password.charCodeAt(i) & 255;\n        else\n            pwBytes[i] = 0;\n    }\n\n    var key = Aes.cipher(pwBytes, Aes.keyExpansion(pwBytes));\n    key = key.concat(key.slice(0, nBytes - 16));\n\n    // recover nonce from 1st 8 bytes of ciphertext\n    var counterBlock = new Uint8Array(8);\n    for (i = 0; i < 8; i++)\n        counterBlock[i] = ciphertext[i];\n\n    // generate key schedule\n    var keySchedule = Aes.keyExpansion(key);\n\n    // separate ciphertext into blocks (skipping past initial 8 bytes)\n    var nBlocks = Math.ceil((ciphertext.length - 8) / blockSize);\n    var ct = new Array(nBlocks);\n    var offset = 8;\n    for (var b = 0; b < nBlocks; b++) {\n        ct[b] = ciphertext.subarray(offset, offset + blockSize);\n        offset += blockSize;\n    }\n    // ct is now array of block-length Uint8Array\n\n    // plaintext will get generated block-by-block into array of\n    // block-length Uint8Arrays\n    var plaintxt = new Array(nBlocks);\n    var size = 0;\n\n    for (b = 0; b < nBlocks; b++) {\n        // set counter (block #) in last 8 bytes of counter block\n        // (leaving nonce in 1st 8 bytes)\n        for (var c = 0; c < 4; c++)\n            counterBlock[15 - c] = ((b) >>> c * 8) & 0xff;\n        for (c = 0; c < 4; c++) {\n            counterBlock[15 - c - 4] =\n                (((b + 1) / 0x100000000 - 1) >>> c * 8) & 0xff;\n        }\n\n        // encrypt counter block\n        var cipherCntr = Aes.cipher(counterBlock, keySchedule);\n\n        var blen = ct[b].length;\n        var plaintxtByte = new Uint8Array(blen);\n        for (i = 0; i < blen; i++) {\n            // xor plaintxt with ciphered counter byte-by-byte\n            plaintxtByte[i] = cipherCntr[i] ^ ct[b][i];\n        }\n        plaintxt[b] = plaintxtByte;\n        size += blen;\n    }\n\n    var pt = new Uint8Array(size);\n    offset = 0;\n    for (b = 0; b < nBlocks; b++) {\n        pt.set(plaintxt[b], offset);\n        offset += plaintxt[b].length;\n    }\n\n    return pt;\n};\n"]}