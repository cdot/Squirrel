{"version":3,"sources":["js/Steganographer.js"],"names":["Steganographer","image","maxChunk","this","Image","src","prototype","adjustToFit","size","bits","slots","naturalWidth","naturalHeight","chunkSize","DEBUG","console","debug","inject","message","a8","Uint8Array","length","shadowCanvas","document","createElement","style","display","width","height","shadowCtx","getContext","drawImage","imageData","getImageData","iData","data","i","a8_i","a8_iM1","a8_len","byte_i","chunkMask","iChunkMask","numChunks","addChunk","c","pending","shift","channel","putImageData","extract","charCode","bitCount","mi","mmi","buffer"],"mappings":";AA0BA,QAASA,gBAAeC,MAAOC,UAC3B,YAQAC,MAAKD,SAAWA,UAAY,EAEP,gBAAVD,QACPE,KAAKF,MAAQ,GAAIG,OACjBD,KAAKF,MAAMI,IAAMJ,OAEjBE,KAAKF,MAAQA,MAYrBD,eAAeM,UAAUC,YAAc,SAASC,MAC5C,YAEA,IAAIC,MAAc,EAAPD,KAKPE,MAAQ,EAAIP,KAAKF,MAAMU,aAAeR,KAAKF,MAAMW,cAAgB,EAEjEC,UAAaJ,KAAOC,MAAQ,GAAM,CAOtC,IANII,OAAOC,QAAQC,MACf,oBAAsBP,KAAO,UAAYD,KAAO,6BAE1CL,KAAKD,SAAWQ,MAAQ,UACxBP,KAAKD,SAAWQ,MAAQ,EAAI,UAElCG,UAAYV,KAAKD,SAMjB,KALIY,QAAOC,QAAQC,MACf,6BAA+BH,UACzB,SAAWV,KAAKD,SAChB,mBAAsBQ,OAASP,KAAKD,SAAWW,WAC/C,SACHH,OAASG,UAAYV,KAAKD,UAC3B,sCAOV,OAJIY,QAAOC,QAAQC,MACf,6BAA+BH,UACzB,KAAOH,MAAQ,WAElBG,WAYXb,eAAeM,UAAUW,OAAS,SAASC,SAGvC,GAAIC,IAAK,GAAIC,YAAWF,QAEpBJ,QAAOC,QAAQC,MACf,mBAAqBG,GAAGE,OAAS,WACd,EAAZF,GAAGE,OAAc,SAE5B,IAAIC,cAAeC,SAASC,cAAc,SAC1CF,cAAaG,MAAMC,QAAU,OAC7BJ,aAAaK,MAAQxB,KAAKF,MAAMU,aAChCW,aAAaM,OAASzB,KAAKF,MAAMW,aAEjC,IAAIiB,WAAYP,aAAaQ,WAAW,KACxCD,WAAUE,UAAU5B,KAAKF,MAAO,EAAG,EAcnC,KAAK,GAZD+B,WAAYH,UAAUI,aACtB,EAAG,EAAGX,aAAaK,MAAOL,aAAaM,QACvCM,MAAQF,UAAUG,KAUbC,EAAI,EAAGA,EAAIF,MAAMb,OAAQe,GAAK,EACnCF,MAAME,GAAK,GAEf,IAuBIC,MACAC,OACA7B,KAzBA8B,OAASpB,GAAGE,OACZR,UAAYV,KAAKI,YAAYgC,QAI7BC,OAAS,GAETC,WAAa,GAAK5B,WAAa,EAC/B6B,YAAcD,UAGdE,UAAY,EACZC,SAAW,SAASC,GACpBX,MAAMM,QAAWN,MAAMM,QAAUE,WAAcG,EAC/CL,SACIA,OAAS,GAAM,GACfA,SACJG,aASAG,QAAU,CACd,KAAKV,EAAI,EAAGA,EAAIG,OAAQH,IAAK,CAYzB,IAXAC,KAAOlB,GAAGiB,GACV3B,KAAO,EACHqC,QAAU,IAGVF,SAAUN,OAAUG,WAAc5B,UAAYiC,SACjCT,KAAQI,WAAaK,UAAaA,SAC/CT,OAAUxB,UAAYiC,QACtBrC,MAASI,UAAYiC,SAGlBrC,MAAQI,WACX+B,SAASP,KAAOI,WAChBJ,OAASxB,UACTJ,MAAQI,SAEZiC,SAAUrC,KACV6B,OAASD,KAETS,QAAU,GAEVF,SAASN,QAMbE,OAAS,CAET,KADA,GAAIO,OAAQ,GACLA,OAAS,GACZ,IAAK,GAAIC,SAAU,EAAGA,QAAU,GAAKD,OAAS,EAAGC,UAC7Cd,MAAMM,QAA2B,IAAhBN,MAAMM,QACfG,WAAaI,MAAS,EAC9BA,OAAS,IACTP,OACa,GAAM,GACfA,QAkBZ,OAbAN,OAAMM,QAA2B,IAAhBN,MAAMM,QAAoB3B,WAAa,EAAK,EAC7D2B,SACAN,MAAMM,QAA2B,IAAhBN,MAAMM,QAA+B,EAAZ3B,UAC1C2B,QAAU,EAEN1B,OAAOC,QAAQC,MACf,kBAAoB2B,UAAY,cAC1B9B,UAAY,UAAa8B,UAAY9B,UAAa,WACjD8B,UAAY9B,UAAY,EAAK,kBAExCmB,UAAUG,KAAOD,MACjBL,UAAUoB,aAAajB,UAAW,EAAG,GAE9BV,cASXtB,eAAeM,UAAU4C,QAAU,WAC/B,YAEA,IAAI5B,cAAeC,SAASC,cAAc,SAC1CF,cAAaG,MAAMC,QAAU,OAC7BJ,aAAaK,MAAQxB,KAAKF,MAAMU,aAChCW,aAAaM,OAASzB,KAAKF,MAAMW,aAEjC,IAAIiB,WAAYP,aAAaQ,WAAW,KACxCD,WAAUE,UAAU5B,KAAKF,MAAO,EAAG,EAUnC,KAAK,GARD+B,WAAYH,UAAUI,aACtB,EAAG,EAAGX,aAAaK,MAAOL,aAAaM,QACvCM,MAAQF,UAAUG,KAIlBQ,UAAY,EACZH,OAAS,EACJJ,EAAI,EAAGA,EAAI,GAAIA,GAAK,EACzBO,UAAaA,WAAa,EAAsB,EAAhBT,MAAMM,UACtCA,OACa,GAAM,GACfA,QAGR,IAAI3B,YAA+B,EAAlBqB,MAAMM,YAAoB,CAI3C,IAHA3B,WAA6B,EAAhBqB,MAAMM,QACnBA,QAAU,EAENG,UAAY,GAAKA,UAAYT,MAAMb,QAChCR,WAAa,GAAKA,UAAY,EACjC,KAAM,qBAEV,IAAIK,SAAU,GAAIE,YAAYuB,UAAY9B,WAAc,EACpDC,QAAOC,QAAQC,MACf,oBAAsB2B,UAAY,cAC5B9B,UAAY,UACX8B,UAAY9B,UAAa,WACzB8B,UAAY9B,UAAY,EAAK,iBAExC,IAAIsC,UAAW,EACXC,SAAW,EACXC,GAAK,EACLZ,WAAa,GAAK5B,WAAa,CAEnC,KAAKuB,EAAI,EAAGA,EAAIO,UAAWP,IAAK,CAC5B,GAAIkB,KAAMpB,MAAMM,UAAYC,SACxBD,QAAS,GAAM,GACfA,SACJW,UAAYG,KAAOF,SACnBA,UAAYvC,UACRuC,UAAY,IACZlC,QAAQmC,MAAmB,IAAXF,SAChBC,UAAY,EACZD,SAAWG,KAAQzC,UAAYuC,UASvC,MANIC,IAAOV,UAAY9B,WAAc,IAEjCK,QAAQmC,MAAmB,IAAXF,UAEhBrC,OAAOC,QAAQC,MACf,mBAAqBE,QAAQG,OAAS,UACnCH,QAAQqC","file":"js/Steganographer.min.js","sourcesContent":["/*@preserve Copyright (C) 2015 Crawford Currie http://c-dot.co.uk license MIT*/\n\n/* global DEBUG */\n\n/* \n * Steganography using the least-significant bits of the\n * colour channels in an image.\n *\n * We use the colour channels because using the alpha channel is a dead\n * giveaway that stenography is being used. Using the colour channels\n * will give some chromatic perturbation than might act as a statistical\n * signature, as a normal image will have runs of equal, or close,\n * pixel values, and injecting random data will confuse that. We try to\n * make it hard to detect by only using a small number of bits from each\n * channel, such that the data just looks like stochastic noise.\n */\n\n/**\n * Constructor.\n * @param image An Image, HTMLImageElement or String data-URL. The image\n * will be used as the source of hidden data, or the template for a new\n * embedded image, depending on what methods you call.\n * @param maxChunk override the default maximum number of bits per colour\n * channel to use. The default is 3, which is a reasonable compromise between\n * information capacity and image degradation.\n */\nfunction Steganographer(image, maxChunk) {\n    \"use strict\";\n\n    // Messages are stored in chunks held in the least significant\n    // bits of the three colour channels. The theoretical maximum\n    // chunk size, using all the bits of the colour channels, would\n    // be 8 bits, but that would replace the image.\n    // The degradation becomes rapidly apparent beyond 3 bits, so that\n    // is our default.\n    this.maxChunk = maxChunk || 3;\n\n    if (typeof image === \"string\") {\n        this.image = new Image();\n        this.image.src = image;\n    } else\n        this.image = image;\n}\n\n/**\n * @private\n * Adjust chunkSize until the data fits as well as\n * possible into the image (minimum number of bits-per-channel used)\n * @param size size of data to fit, in bytes\n * @param image image to fit it in\n * @return chunkSize if the image can be made to fit, -1 times\n * the number of bits that can't be stored otherwise\n */\nSteganographer.prototype.adjustToFit = function(size) {\n    \"use strict\";\n\n    var bits = size * 8; // Number of bits to be stored\n    \n    // number of chunks (32 bits) and chunk size (4 bits) are stored\n    // 2 bits per channel, so that means 18 channels, 3 channels\n    // per pixel so need 6 pixels for this info.\n    var slots = 3 * this.image.naturalWidth * this.image.naturalHeight - 6;\n\n    var chunkSize = (bits / slots + 1) >> 0;\n    if (DEBUG) console.debug(\n        \"Storage required \" + bits + \" bits, \" + size + \" bytes\"\n            + \" Max image capacity \"\n            + this.maxChunk * slots + \" bits, \"\n            + this.maxChunk * slots / 8 + \" bytes\");\n\n    if (chunkSize > this.maxChunk) {\n        if (DEBUG) console.debug(\n            \"Steg: Computed chunk size \" + chunkSize\n                + \" is > \" + this.maxChunk\n                + \", oversized by \" + (-slots * (this.maxChunk - chunkSize))\n                + \" bits\");\n        throw (slots * (chunkSize - this.maxChunk))\n            + \" bits too many to hide in this image\";\n    }\n\n    if (DEBUG) console.debug(\n        \"Steg: Computed chunk size \" + chunkSize\n            + \" (\" + slots + \" slots)\");\n\n    return chunkSize;\n};\n\n/**\n * Inject some content into the given image\n * @param data the content, in an ArrayBuffer. Size must be <= (2^32-1)\n * @return a canvas object containing the resulting image, not\n * attached to the document.\n * @throws if the image doesn't have enough capacity given the\n * current parameters. The exception is a structure containing a message\n * and the number of bits that could *not* be accomodated.\n */\nSteganographer.prototype.inject = function(message) {\n    // Can't \"use strict\"; because of the image manipultaion\n\n    var a8 = new Uint8Array(message);\n\n    if (DEBUG) console.debug(\n        \"Steg: Embedding \" + a8.length + \" bytes (\"\n            + (a8.length * 8) + \" bits)\");\n\n    var shadowCanvas = document.createElement(\"canvas\");\n    shadowCanvas.style.display = \"none\";\n    shadowCanvas.width = this.image.naturalWidth;\n    shadowCanvas.height = this.image.naturalHeight;\n\n    var shadowCtx = shadowCanvas.getContext(\"2d\");\n    shadowCtx.drawImage(this.image, 0, 0);\n\n    var imageData = shadowCtx.getImageData(\n        0, 0, shadowCanvas.width, shadowCanvas.height);\n    var iData = imageData.data;\n\n    // The image data consists of width*height pixels, where each pixel\n    // is 4 bytes (RGBA)\n\n    // We have to init the alpha channel of the image to fully opaque,\n    // otherwise color values can't be manipulated. If we manipulate\n    // colour, we can't modify transparency, and if we manipulate\n    // transparency, we lose control over colour. Better on balance to\n    // use the colour channels to store our secrets.\n    for (var i = 3; i < iData.length; i += 4)\n        iData[i] = 0xFF;\n\n    var a8_len = a8.length;\n    var chunkSize = this.adjustToFit(a8_len);\n\n    // We reserve the first 24 bytes (6 pixels) for the data length (32 bits)\n    // and chunk size (4 bits) packed 2 bits per colour channel.\n    var byte_i = 24;\n\n    var chunkMask = (1 << chunkSize) - 1;\n    var iChunkMask = ~chunkMask;\n\n    // Function to add a chunk into the image. c <= chunkMask\n    var numChunks = 0;\n    var addChunk = function(c) {\n        iData[byte_i] = (iData[byte_i] & iChunkMask) | c;\n        byte_i++;\n        if (byte_i % 4 === 3)\n            byte_i++; // skip alpha channel\n        numChunks++;\n    };\n    \n    // 00000001 00000010 00000011 00000100 00000101\n    // 001 000 000 001 000 110 000 000 100 000 100\n    //   1   0   0   1   0   6   0   0   4   0   4\n    var a8_i;        // the i'th byte, shifted as we remove chunks\n    var a8_iM1;      // what remains of the i-1'th byte\n    var bits;        // Number of bits remaining to process in the i'th byte\n    var pending = 0; // number of bits still pending from the i-1'th byte\n    for (i = 0; i < a8_len; i++) {\n        a8_i = a8[i];\n        bits = 8;\n        if (pending > 0) {\n            // Remaining (high) bits of previous byte combined with\n            // low order bits of current byte\n            addChunk((a8_iM1 & (chunkMask >> (chunkSize - pending)))\n                     | ((a8_i & (chunkMask >> pending)) << pending));\n            a8_i >>= (chunkSize - pending);\n            bits -= (chunkSize - pending);\n        }\n        // Get as many whole chunks from the byte as we can\n        while (bits >= chunkSize) {\n            addChunk(a8_i & chunkMask);\n            a8_i >>= chunkSize;\n            bits -= chunkSize;\n        }\n        pending = bits;\n        a8_iM1 = a8_i;\n    }\n    if (pending > 0) {\n        // Push the final partial chunk\n        addChunk(a8_iM1);\n    }\n\n    // Embed data length and chunkSize using 2 bits from each\n    // colour channel (6 bits per pixel, 32 bit length + 4 bit chunksize\n    // = 36bits, so 6 pixels (24 bytes) is just perfect.\n    byte_i = 0;\n    var shift = 30;\n    while (shift >= 0) {\n        for (var channel = 0; channel < 3 && shift >= 0; channel++) {\n            iData[byte_i] = (iData[byte_i] & 0xFC)\n                | ((numChunks >> shift) & 0x3);\n            shift -= 2;\n            byte_i++;\n            if (byte_i % 4 === 3)\n                byte_i++; // skip alpha channel\n        }\n    }\n\n    // That leaves just two channels for 2 bits of the chunkSize each\n    iData[byte_i] = (iData[byte_i] & 0xFC) | ((chunkSize >> 2) & 0x3);\n    byte_i++;\n    iData[byte_i] = (iData[byte_i] & 0xFC) | (chunkSize & 0x3);\n    byte_i += 2; // blue + alpha\n\n    if (DEBUG) console.debug(\n        \"Steg: Embedded \" + numChunks + \" chunks of \"\n            + chunkSize + \" bits, \" + (numChunks * chunkSize) + \" bits / \"\n            + (numChunks * chunkSize / 8) + \" bytes of data\");\n\n    imageData.data = iData;\n    shadowCtx.putImageData(imageData, 0, 0);\n\n    return shadowCanvas;\n};\n\n/**\n * Extract the content hidden in the given image\n * @param image An Image, HTMLImageElement or data-URL to embed the message in\n * @return an ArrayBuffer containing the content\n * @throws if the image doesn't seem to have anything embedded\n */\nSteganographer.prototype.extract = function() {\n    \"use strict\";\n\n    var shadowCanvas = document.createElement(\"canvas\");\n    shadowCanvas.style.display = \"none\";\n    shadowCanvas.width = this.image.naturalWidth;\n    shadowCanvas.height = this.image.naturalHeight;\n\n    var shadowCtx = shadowCanvas.getContext(\"2d\");\n    shadowCtx.drawImage(this.image, 0, 0);\n\n    var imageData = shadowCtx.getImageData(\n        0, 0, shadowCanvas.width, shadowCanvas.height);\n    var iData = imageData.data;\n\n    // Extract data length and chunkSize\n    // chunkSize = 4, prime = 17\n    var numChunks = 0;\n    var byte_i = 0;\n    for (var i = 0; i < 32; i += 2) {\n        numChunks = (numChunks << 2) | (iData[byte_i] & 0x3);\n        byte_i++;\n        if (byte_i % 4 === 3)\n            byte_i++; // skip alpha channel\n    }\n\n    var chunkSize = (iData[byte_i++] & 0x3) << 2;\n    chunkSize |= iData[byte_i] & 0x3;\n    byte_i += 2; // blue and alpha\n\n    if (numChunks < 0 || numChunks > iData.length\n        || chunkSize <= 0 || chunkSize > 8)\n        throw \"No message embedded\";\n\n    var message = new Uint8Array((numChunks * chunkSize) >> 3);\n    if (DEBUG) console.debug(\n        \"Steg: Extracting \" + numChunks + \" chunks of \"\n            + chunkSize + \" bits, \"\n            + (numChunks * chunkSize) + \" bits / \"\n            + (numChunks * chunkSize / 8) + \" bytes of data\");\n\n    var charCode = 0;\n    var bitCount = 0;\n    var mi = 0;\n    var chunkMask = (1 << chunkSize) - 1;\n\n    for (i = 0; i < numChunks; i++) {\n        var mmi = iData[byte_i++] & chunkMask;\n        if (byte_i % 4 === 3)\n            byte_i++; // skip alpha channel\n        charCode |= mmi << bitCount;\n        bitCount += chunkSize;\n        if (bitCount >= 8) {\n            message[mi++] = charCode & 0xFF;\n            bitCount %= 8;\n            charCode = mmi >> (chunkSize - bitCount);\n        }\n    }\n    if (mi < ((numChunks * chunkSize) >> 3)) {\n        //console.debug(\"unwhak \" + charCode);\n        message[mi++] = charCode & 0xFF;\n    }\n    if (DEBUG) console.debug(\n        \"Steg: Extracted \" + message.length + \" bytes\");\n    return message.buffer;\n};\n"]}