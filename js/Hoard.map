{"version":3,"sources":["js/Hoard.js"],"names":["Hoard","data","this","last_sync","actions","cache","options","clear_actions","autosave","store_path","stringify_action","action","type","path","join","Date","time","toLocaleString","prototype","record_action","e","listener","no_push","locateParent","node","i","length","name","DEBUG","c","mess","conflict","message","now","push","slice","parent","TX","tx","new_parent","npp","alarm","call","simplify","chain","_reconstruct_actions","self","queue","handle_node","p","ready","pal","list_nodes","q","pat","key","Utils","execute_queue","actions_from_hierarchy","reconstruct_actions","merge_from_cloud","cloud","local_actions","conflicts","console","debug","dump","JSON","get_node","each_alarm","alarum","check","item","pop","snode","concat","MSPERDAY","check_alarms","callback","stringify"],"mappings":"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","file":"js/Hoard.min.js","sourcesContent":["/*@preserve Copyright (C) 2015 Crawford Currie http://c-dot.co.uk license MIT*/\n\n/* global DEBUG */\n/* global TX */\n/* global Utils */\n\n/**\n * A combined hierarchical data store with change log, designed to be\n * used in a client-cloud topology where a single cloud hoard is synched\n * with multiple client stores, each of which may change asynchronously.\n *\n * On the client side, the hoard contains a cache that represents\n * the current data in the hoard. Then it has a list of\n * actions that record the list of actions performed on the cache since the\n * last sync. These changes are already reflected in the cache, but are kept\n * until the hoard is synched with the cloud hoard.\n * \n * In the cloud hoard the cache is maintained empty, and the list of actions\n * represents all changes since the hoard was established. These can be\n * replayed in full to regenerate the cache, though this is a time-consuming\n * business. At any time the hoard can be optimised - basically blowing away\n * all the history. This should only be done if you are sure all clients are\n * up-to-date.\n *\n * @typedef Action\n * @type {object}\n * @property {string} type - single character type\n * @property {string[]} path - node path\n * @property {Object} data - optional data object\n *\n * @typedef Conflict\n * @type {object}\n * @property {Action} action\n * @property {string} message\n *\n * @typedef Data\n * @type {object}\n * @property {Data[]|string} colelction of subnodes, or leaf data if\n * this is string\n * @property time {integer} time of the last modification\n *\n * @callback Listener\n * @param {Action} action\n * @param {Function} chain\n */\n\n/**\n * Create a new Hoard\n * @class\n * @member {Data} cache root of the data structure\n * @member {Action[]} actions actions played since the last sync\n * @member {number} last_sync integer date since the last sync, or null\n */\nfunction Hoard(data) {\n    \"use strict\";\n\n    if (data) {\n        this.last_sync = data.last_sync;\n        this.actions = data.actions;\n        this.cache = data.cache;\n        this.options = data.options;\n    } else {\n        this.last_sync = null;\n        this.clear_actions();\n        this.cache = null;\n    }\n    if (typeof this.options === \"undefined\")\n        this.options = {\n            // options exist in both the client and cloud stores, but\n            // are only read from the client - they are never read\n            // from the cloud. This is so that (for example) a tablet\n            // doesn't get the autosave option when it spends most of\n            // its time disconnected.\n\n            // Is autosave turned on?\n            autosave: false,\n\n            // What's the server path to the hoard store?\n            store_path: null\n        };\n}\n\nHoard.stringify_action = function(action) {\n    \"use strict\";\n\n    return action.type + \":\"\n        + action.path.join(\"/\")\n        + (typeof action.data !== \"undefined\" ?\n           (\" '\" + action.data + \"'\") : \"\")\n        + \" @\" + new Date(action.time).toLocaleString();\n};\n\n/**\n * Clear down the actions in the hoard. The cache is left untouched.\n * This is used when the client hoard has been synched with the cloud\n * and the local actions list is no longer needed.\n */\nHoard.prototype.clear_actions = function() {\n    \"use strict\";\n\n    this.actions = [];\n};\n\n/**\n * Play a single action into the hoard. The cache is updated, and\n * the action added to the action stream ready for the next synch.\n * Apply the given action type:\n * <ul>\n * <li>'N' with no data - create collection</li>\n * <li>'N' with data - create leaf</li>\n * <li>'D' delete node, no data. Will delete the entire node tree.</li>\n * <li>'E' edit node - modify the leaf data in a node</li>\n * <li>'R' rename node, data contains new name</li>\n * </ul>\n * Returns a conflict object if there was an error. This has two fields,\n * 'action' for the action record and 'message'.\n * @param {Action} e the action record\n * @param {Listener} [listener] called when the action is played\n * @param no_push {boolean} if true, don't push played actions onto the\n * action stream\n * @return {Conflict} conflict object, or null if there was no conflict\n */\nHoard.prototype.record_action = function(e, listener, no_push) {\n    \"use strict\";\n\n    if (typeof e.time === \"undefined\" || e.time === null)\n        e.time = Date.now();\n\n    if (!no_push)\n        this.actions.push({\n            type: e.type,\n            path: e.path.slice(),\n            time: e.time,\n            data: e.data\n        });\n\n    function locateParent(path, node) {\n        // Locate the parent in the cache\n        for (var i = 0; i < path.length - 1; i++) {\n            var name = path[i];\n            if (node && typeof node.data === \"string\") {\n                // \"Cannot \" + e.type + \" over leaf node\";\n                if (DEBUG) debugger;\n            } else if (node && node.data[name]) {\n                node = node.data[name];\n            } else {\n                return undefined;\n            }\n        }\n        // Should now be positioned one above the end of the path\n        return node;\n    }\n\n    function c(mess) {\n        return { conflict: e, message: mess };\n    }\n\n    var parent = locateParent(e.path, this.cache);\n    if (!parent) {\n        if (this.cache) {\n            return c(\"'\" + e.path.join(\"/\") + \"' \"\n                     + TX.tx(\"parent not found\"));\n        } else {\n            parent = this.cache = { data: {} };\n        }\n    }\n\n    var name = e.path[e.path.length - 1];\n    var node = parent.data[name];\n\n    switch (e.type) {\n    case \"N\": // New\n        if (node)\n            return c(TX.tx(\"Cannot create, '$1' already exists\",\n                           e.path.join(\"/\")));\n        parent.time = e.time; // collection is being modified\n        parent.data[name] = {\n            time: e.time,\n            data: (typeof e.data === \"string\") ?\n                e.data : {}\n        };\n        break;\n\n    case \"M\": // Move\n        if (!node) {\n            return c(TX.tx(\"Cannot move, '$1' does not exist\",\n                           e.path.join(\"/\")));\n        }\n\n        // e.data is the path of the new parent\n        if (e.data.length > 0) {\n            var npp = locateParent(e.data, this.cache), new_parent;\n            if (npp)\n                new_parent = npp.data[e.data[e.data.length - 1]];\n        }\n        else\n            new_parent = this.cache; // root\n        \n        if (!new_parent)\n            return c(\"Cannot move, '\" + e.data.join(\"/\") + \"' \"\n                     + TX.tx(\"does not exist\"));\n\n        new_parent.time = parent.time = e.time; // collection is being modified\n        delete parent.data[name];\n        new_parent.data[name] = node;\n        break;\n\n    case \"D\": // Delete\n        if (!node)\n            return c(TX.tx(\"Cannot delete, '$1' does not exist\",\n                           e.path.join(\"/\")));\n        delete parent.data[name];\n        parent.time = e.time; // collection is being modified\n        break;\n\n    case \"R\": // Rename\n        if (!parent.data[name])\n            return c(TX.tx(\"Cannot rename, '$1' does not exist\",\n                          e.path.join(\"/\")));\n        if (parent.data[e.data])\n            return c(TX.tx(\"Cannot rename '$1', '$2' already exists\",\n                           e.path.join(\"/\"), e.data));\n        parent.data[e.data] = parent.data[name];\n        delete parent.data[name];\n        parent.time = e.time; // collection is being modified\n        break;\n\n    case \"E\": // Edit\n        if (!parent.data[name])\n            return c(TX.tx(\"Cannot change value, '$1' does not exist\",\n                           e.path.join(\"/\")));\n        parent.data[name].data = e.data;\n        parent.data[name].time = e.time;\n        break;\n\n    case \"A\": // Alarm\n        if (!parent.data[name])\n            return c(TX.tx(\"Cannot set reminder, '$1' does not exist\",\n                           e.path.join(\"/\")));\n        parent.data[name].alarm = e.data;\n        break;\n\n    case \"C\": // Cancel alarm\n        if (!parent.data[name])\n            return c(TX.tx(\"Cannot cancel reminder, '$1' does not exist\",\n                           e.path.join(\"/\")));\n        delete parent.data[name].alarm;\n        break;\n\n    default:\n        // Internal error unrecognised action type\n        if (DEBUG) debugger;\n    }\n\n    if (listener)\n        listener.call(this, e);\n\n    return null;\n};\n\n/**\n * Simplify the action stream in the hoard by eliminating all but \"N\" actions.\n * Set node change times according to the most recent change.\n * Designed to be used on the cloud hoard, this will result in an empty\n * cache and simplified action stream. Note that this will destroy the\n * cache.\n */\nHoard.prototype.simplify = function(chain) {\n    \"use strict\";\n\n    // First reconstruct the cache by playing all the actions\n    this.cache = null;\n    if (this.actions) {\n        for (var i = 0; i < this.actions.length; i++) {\n            // Play the action with no push and no listener\n            var er = this.record_action(this.actions[i], false, true);\n            if (DEBUG && er !== null) debugger;\n        }\n    }\n\n    // Now reconstruct the action stream from the simplified cache\n    this.actions = [];\n    if (this.cache) {\n        this._reconstruct_actions(\n            this.cache.data, [], function(e) {\n                this.actions.push({\n                    type: e.type,\n                    time: e.time,\n                    data: e.data,\n                    path: e.path.slice()\n                });\n            },\n            chain);\n        this.cache = null;\n    } else if (chain)\n        chain();\n};\n\n/**\n * @private method to reconstruct an action stream from a node and it's\n * subtree. Relies on the listener to call the next function.\n */\nHoard.prototype._reconstruct_actions = function(data, path, listener, chain) {\n    \"use strict\";\n\n    var self = this;\n    var queue = [];\n\n    // Handle a node\n    var handle_node = function(node, p, ready) {\n        if (p.length === 0) {\n            // No action for the root\n            ready();\n            return;\n        }\n        var time = (typeof node.time !== \"undefined\" ? node.time : Date.now());\n        var action = {\n            type: \"N\",\n            path: p,\n            time: time\n        };\n\n        if (typeof node.data === \"string\")\n            action.data = node.data;      \n        else if (DEBUG && typeof node.data === \"undefined\")\n            debugger;\n\n        // slice this time, to avoid re-use of the same object\n        // in alarms\n        var pal = p.slice();\n        listener.call(\n            self,\n            action,\n            function() {\n                if (node.alarm) {\n                    listener.call(\n                        self,\n                        {\n                            type: \"A\", \n                            path: pal,\n                            time: time,\n                            data: node.alarm\n                        });\n                }\n                ready();\n            });\n    };\n\n    // Recursively build a list of all nodes, starting at the root\n    var list_nodes = function(q, node, pat) {\n        var key, p;\n        q.push(function(ready) {\n            handle_node(node, pat, ready);\n        });\n        if (typeof node.data === \"object\") {\n            for (key in node.data) {\n                p = pat.slice();\n                p.push(key);\n                list_nodes(q, node.data[key], p);\n            }\n        }\n    };\n\n    list_nodes(queue, data, path.slice());\n    queue.push(chain);\n    Utils.execute_queue(queue);\n};\n\n/**\n * Reconstruct an action stream (which will all be 'N' actions) from\n * a data block. Does not (directly) affect the actions stored in\n * the hoard (though the listener might).\n * @param data data structure, a simple hierarchical structure\n * of keys and the data they contain e.g.\n * { \"key1\" : { data: { subkey1: { data: \"string data\" } } } }\n * Other fields (such as time) may be present and are used if they are.\n * @param {Listener} [listener] callback that takes an action, and a\n * function that must be called once the action has been applied. Note that\n * the listener can do what it likes with the action it is passed, and\n * the function need not be called immediately.\n * @param chain callback invoked when all actions have been constructed\n * (no parameters, no this)\n */\nHoard.prototype.actions_from_hierarchy = function(data, listener, chain) {\n    \"use strict\";\n\n    this._reconstruct_actions(data, [], listener, chain);\n};\n\n/**\n * Reconstruct an action stream from the cache in the hoard. This is\n * used to generate the UI tree from a stored cache. \n * @param {Listener} [listener] callback that takes an action, and a\n * function that must be called once the action has been applied. Note that\n * the listener can do what it likes with the action it is passed, and\n * the function need not be called immediately.\n * @param chain callback invoked when all actions have been constructed\n * (no parameters, no this)\n */\nHoard.prototype.reconstruct_actions = function(listener, chain) {\n    \"use strict\";\n\n    if (this.cache) {\n        this.actions_from_hierarchy(this.cache, listener, chain);\n    } else {\n        chain();\n    }\n};\n\n/**\n * Merge the cloud actions since the last sync into this hoard.\n * Actions are *not* appended to our local actions stream.\n * @param {Hoard} cloud the cloud hoard\n * @param {Listener} [listener] called whenever an action is played\n * @param {Object[]} conflicts, as returned by record_action, if there are any\n * @param chain function to call once all merged. Passed a list of conflicts.\n */\nHoard.prototype.merge_from_cloud = function(cloud, listener, chain) {\n    \"use strict\";\n\n    var i, c,\n    // Save the local action stream\n    local_actions = this.actions,\n    conflicts = [];\n\n    // Play in all cloud actions since the last sync\n    this.actions = [];\n    for (i = 0; i < cloud.actions.length; i++) {\n        if (cloud.actions[i].time > this.last_sync) {\n            if (DEBUG) console.debug(\n                \"Merge \" + Hoard.stringify_action(cloud.actions[i]));\n            c = this.record_action(cloud.actions[i], listener, true);\n            if (c !== null) {\n                if (DEBUG) console.debug(\"Conflict: \" + c.message);\n                conflicts.push(c);\n            }\n        }\n        else if (DEBUG) {\n            console.debug(\n                \"Skip \" + Hoard.stringify_action(cloud.actions[i]));\n        }\n    }\n\n    // Restore the saved actions list\n    this.actions = local_actions;\n    this.last_sync = Date.now();\n    if (chain)\n        chain(conflicts);\n};\n\n/**\n * Return a dump of the current state of the hoard.\n * @return a string with the JSON of the cache, and a list of the actions.\n */\nHoard.prototype.dump = function() {\n    \"use strict\";\n\n    var data = this.JSON() + \"\\n\"; // get the cache\n    for (var i = 0; i < this.actions.length; i++) {\n        data = data + Hoard.stringify_action(this.actions[i]) + \"\\n\";\n    }\n    return data;\n};\n\n/**\n * Return the cache node identified by the path.\n * @return a cache node, or null if not found.\n */\nHoard.prototype.get_node = function(path) {\n    \"use strict\";\n\n    var node = this.cache, i;\n    for (i = 0; i < path.length; i++) {\n        if (typeof node.data === \"string\")\n            return null;\n        node = node.data[path[i]];\n    }\n    return node;\n};\n\n/**\n* @private\n*/\nHoard.prototype.each_alarm = function() {\n    \"use strict\";\n\n    var self = this,\n    alarum = function() {\n        self.each_alarm();\n    };\n\n    while (this.check && this.check.queue.length > 0) {\n        var item = this.check.queue.pop(),\n        node = item.node, name;\n\n        if (typeof node.data === \"object\")\n            for (name in node.data) {\n                var snode = node.data[name];\n                this.check.queue.push({\n                    node: snode,\n                    path: item.path.slice().concat([ name ])\n                });\n            }\n\n        if (typeof node.alarm !== \"undefined\"\n            && (Date.now() - node.time) >= (node.alarm * Utils.MSPERDAY)) {\n            this.check.alarm(\n                item.path,\n                new Date(node.time + node.alarm * Utils.MSPERDAY),\n                alarum);\n            return;\n        }\n    }\n    delete this.check;\n};\n\n/**\n * Check alarms, calling callback on all alarms that have fired\n */\nHoard.prototype.check_alarms = function(callback) {\n    \"use strict\";\n\n    if (!this.cache)\n        return;\n    this.check = {\n        queue: [ { path: [], node: this.cache } ],\n        alarm: callback\n    };\n    this.each_alarm();\n};\n\n/**\n * Generate a JSON dump of the cache.\n * @return a string containing a formatted JSON dump\n */\nHoard.prototype.JSON = function() {\n    \"use strict\";\n\n    var data = \"\";\n    if (this.cache)\n        data = JSON.stringify(this.cache.data, null, \"\\t\");\n    return data;\n};\n"]}