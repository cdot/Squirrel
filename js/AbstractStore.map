{"version":3,"sources":["js/AbstractStore.js"],"names":["AbstractStore","params","ok","call","this","LayeredStore","self","pok","engine","understore","NODATA","prototype","options","identifier","user","suser","pass","arguments","length","spass","write","path","data","fail","writes","str","Utils","StringToArrayBuffer","read","reads","ab","ArrayBufferToString","e","DEBUG","console","debug","Object","create","u","pw"],"mappings":";AA2BA,QAASA,eAAcC,QACnB,YACAA,QAAOC,GAAGC,KAAKC,MA4HnB,QAASC,cAAaJ,QAClB,YAEA,IAAIK,MAAOF,KAAMG,IAAMN,OAAOC,EAG9BD,QAAOC,GAAK,WAKRI,KAAKE,OAASJ,KACdG,IAAIJ,KAAKG,OAKbL,OAAOQ,WAAWR,QAxItBD,cAAcU,OAAS,YAMvBV,cAAcW,UAAUC,QAAU,WAC9B,YAEA,QAASC,WAAY,YAQzBb,cAAcW,UAAUG,KAAO,SAASA,MACpC,YAKA,YAHoB,KAATA,OAEPV,KAAKW,MAAQD,MACVV,KAAKW,OAQhBf,cAAcW,UAAUK,KAAO,SAASA,MACpC,YAKA,OAHyB,KAArBC,UAAUC,YAAgC,KAATF,OAEjCZ,KAAKe,MAAQH,MACVZ,KAAKe,OAUhBnB,cAAcW,UAAUS,MAAQ,SAASC,KAAMC,KAAMpB,GAAIqB,MACrD,YAEAA,MAAKpB,KAAKC,KAAM,8BAUpBJ,cAAcW,UAAUa,OAAS,SAASH,KAAMI,IAAKvB,GAAIqB,MACrD,YAEAnB,MAAKgB,MACDC,KACAK,MAAMC,oBAAoBF,KAC1BvB,GACAqB,OASRvB,cAAcW,UAAUiB,KAAO,SAASP,KAAMnB,GAAIqB,MAC9C,YAEAA,MAAKpB,KAAKC,KAAM,6BASpBJ,cAAcW,UAAUkB,MAAQ,SAASR,KAAMnB,GAAIqB,MAC/C,YAEA,IAAIjB,MAAOF,IAEXA,MAAKwB,KACDP,KACA,SAASS,IACL,GAAIR,KACJ,KACIA,KAAOI,MAAMK,oBAAoBD,IACnC,MAAOE,GAGL,MAFIC,QAAOC,QAAQC,MAAM,UAAYH,OACrCT,MAAKpB,KAAKG,KAAM0B,GAGpB9B,GAAGC,KAAKG,KAAMgB,OAElBC,OAiCRlB,aAAaM,UAAYyB,OAAOC,OAAOrC,cAAcW,WAErDN,aAAaM,UAAUC,QAAU,WAC7B,YAEA,OAAOR,MAAKI,OAAOI,WAGvBP,aAAaM,UAAUG,KAAO,SAASwB,GACnC,YAEA,OAAOlC,MAAKI,OAAOM,KAAKwB,IAG5BjC,aAAaM,UAAUK,KAAO,SAASuB,IACnC,YAEA,OAAOnC,MAAKI,OAAOQ,KAAKuB","file":"js/AbstractStore.min.js","sourcesContent":["/*@preserve Copyright (C) 2015 Crawford Currie http://c-dot.co.uk license MIT*/\n\n/* global DEBUG */\n/* global Utils */\n\n/**\n * Pure virtual base class of store providers.\n *\n * Store providers provide a simple file system interface to data in the\n * store. Data is passed back and forth in ArrayBuffer.\n *\n * This module provides two store provider virtual base classes,\n * AbstractStore (which is the base class of all stores) and LayeredStore\n * (which is an AbstractStore in which an underlying \"engine\" store provides\n * the actual storage services)\n */\n\n/**\n * The standard pattern is for the constructor to take a callback as\n * parameter to the create and invoke that callback when the store\n * is ready for use.\n *\n * @class\n * @param params default fields (some stores may require more)\n *    * ok, called on success\n *    * fail, called on failure\n */\nfunction AbstractStore(params) {\n    \"use strict\";\n    params.ok.call(this);\n}\n\n// Special error message, must be used when a store is otherwise OK but\n// data being read is missing.\nAbstractStore.NODATA = \"not found\";\n\n/**\n * Return a hash of static options. This is never written, entries are\n * constants.\n */\nAbstractStore.prototype.options = function() {\n    \"use strict\";\n\n    return { identifier: \"Unknown\" };\n};\n\n/**\n * Set/get the user on the store. Only relevant on stores that are\n * protected by passwords.\n * @param pass the new password\n */\nAbstractStore.prototype.user = function(user) {\n    \"use strict\";\n\n    if (typeof user !== \"undefined\")\n        // .suser to avoid name conflict with .user()\n        this.suser = user;\n    return this.suser;\n};\n\n/**\n * Set/get the password on the store. Only relevant on stores that are\n * protected by passwords.\n * @param pass the new password\n */\nAbstractStore.prototype.pass = function(pass) {\n    \"use strict\";\n\n    if (arguments.length === 1 && typeof pass !== \"undefined\")\n        // .spass to avoid name conflict with .pass()\n        this.spass = pass;\n    return this.spass;\n};\n\n/**\n * Write data. Pure virtual.\n * @param path pathname to store the data under, a / separated path string\n * @param data an ArrayBuffer (or ArrayBufferView, so it can be a TypedArray)\n * @param ok called on success with this=self\n * @param fail called on failure with this=self\n */\nAbstractStore.prototype.write = function(path, data, ok, fail) {\n    \"use strict\";\n\n    fail.call(this, \"Store has no write method\");\n};\n\n/**\n * Write a string.\n * @param path pathname the data is stored under, a / separated path string\n * @param str the data String\n * @param ok called on success with this=self\n * @param fail called on failure\n */\nAbstractStore.prototype.writes = function(path, str, ok, fail) {\n    \"use strict\";\n\n    this.write(\n        path,\n        Utils.StringToArrayBuffer(str),\n        ok,\n        fail);\n};\n\n/**\n * Read an ArrayBuffer. Pure virtual.\n * @param path pathname the data is stored under, a / separated path string\n * @param ok called on success with this=self, passed ArrayBuffer\n * @param fail called on failure\n */\nAbstractStore.prototype.read = function(path, ok, fail) {\n    \"use strict\";\n\n    fail.call(this, \"Store has no read method\");\n};\n\n/**\n * Read a string.\n * @param path pathname the data is stored under, a / separated path string\n * @param ok called on success with this=self, passed String\n * @param fail called on failure\n */\nAbstractStore.prototype.reads = function(path, ok, fail) {\n    \"use strict\";\n\n    var self = this;\n\n    this.read(\n        path,\n        function(ab) {\n            var data;\n            try {\n                data = Utils.ArrayBufferToString(ab);\n            } catch (e) {\n                if (DEBUG) console.debug(\"Caught \" + e);\n                fail.call(self, e);\n                return;\n            }\n            ok.call(self, data);\n        },\n        fail);\n};\n\n/**\n * @class\n * A LayeredStore is an AbstractStore where actual store services are provided\n * by another underlying AbstractStore. A LayeredStore is used where data to\n * be stored/read is to be preprocessed, for example through encryption.\n * To the AbstractStore constructor params options we add the 'understore'\n * option (required) which must be a function that will construct\n * the underlying store to be used as the engine, using parameters passed\n * down.\n */\nfunction LayeredStore(params) {\n    \"use strict\";\n\n    var self = this, pok = params.ok;\n\n    // Override the OK function\n    params.ok = function() {\n        // 'this' is the engine.\n        // Don't call AbstractStore(), it doesn't do anything useful\n        // for us - we don't want to call params.ok for this layer,\n        // only in the understore.\n        self.engine = this;\n        pok.call(self);\n    };    \n\n    // We don't use the return value from the understore factory, instead\n    // we set self.engine in the ok function, above.\n    params.understore(params);\n}\n\nLayeredStore.prototype = Object.create(AbstractStore.prototype);\n\nLayeredStore.prototype.options = function() {\n    \"use strict\";\n\n    return this.engine.options();\n};\n\nLayeredStore.prototype.user = function(u) {\n    \"use strict\";\n\n    return this.engine.user(u);\n};\n\nLayeredStore.prototype.pass = function(pw) {\n    \"use strict\";\n\n    return this.engine.pass(pw);\n};\n"]}