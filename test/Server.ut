/*@preserve Copyright (C) 2016-2018 Crawford Currie http://c-dot.co.uk license MIT*/
/*eslint-env node, mocha */

if (typeof module !== 'undefined') {
  requirejs = require('requirejs');
  requirejs.config({
    baseUrl: `${__dirname}/..`
  });
}

// Was using chai-http, but couldn't work out how to test the body
// of a response :-( So use "Request" instead, as described in
// https://davidbeath.com/posts/testing-http-responses-in-nodejs.html
requirejs(["js/Utils", "js/Cryptographer", "js/Server", "fs", "axios", "test/TestRunner"], function(Utils, Cryptographer, Server, fs, request, TestRunner) {

	let Fs = fs.promises;
  let tr = new TestRunner("Server");
  let assert = tr.assert;
  const workingLocation = "working";
  const workingDir = __dirname + '/' + workingLocation;

  // The server will start in the directory where the test lives
  let server_config = {
    //debug: console.debug,
    //log: console.log,
    port: 13198,
    docroot: __dirname,
    writable: workingLocation,
    //debug: true, log_requests: true,
    auth: {
      user: "test",
      pass: "x",
      realm: "Test Server"}
  };

  const serverUrl = "http://localhost:" + server_config.port;
  const workingUrl = serverUrl + '/' + workingLocation;

  tr.addTest("no-auth-get", () => {
    return request.get(serverUrl + '/')
    .then(r => {
      console.log(r);
      assert(false, "Unexpected");
    })
    .catch(e => {
      assert.equal(e.response.status, 401);
    });
  });

  tr.addTest("bad-auth-get", () => {
    return request
    .get(workingUrl, {
      auth: { username: "plum", password: "fairy" }
    })
    .then(() => {
      assert("Unexpected");
    })
    .catch(e => {
      assert.equal(e.response.status, 401);
    });
  });

  tr.addTest("bad-root-get", () => {
    return request.get(serverUrl + '/', {
      auth: {
        username: server_config.auth.user,
        password: server_config.auth.pass
      }
    })
    .then(() => {
      assert("Unexpected");
    })
    .catch(err => {
      assert.equal(err.response.status, 500);
      assert.equal(err.response.data, "Error: EISDIR: illegal operation on a directory, readError: EISDIR: illegal operation on a directory, read");
    });
  });

  tr.addTest("doesnt_support_post", () => {
    return request.post(serverUrl + '/', {
      auth: {
        username: server_config.auth.user,
        password: server_config.auth.pass
      }
    })
    .then(() => {
      assert("Unexpected");
    })
    .catch(e => {
      assert.equal(e.response.status, 405);
      assert.equal(e.response.data, "No support for POST");
    });
  });

  tr.addTest("text-file-get-8bit", () => {
    return request.get(serverUrl + '/testData.8', {
      auth: { username: server_config.auth.user,
              password: server_config.auth.pass },
      encoding: null
    })
    .then(res => {
      assert.equal(res.data, "Some 8 bit text");
    });
  });

  tr.addTest("text-file-get-16bit", () => {
    return request.get(serverUrl + '/testData.16', {
      auth: { username: server_config.auth.user,
              password: server_config.auth.pass },
      encoding: null
    })
		.then(res => {
      assert.equal(res.status, 200);
      assert.equal(res.headers['content-type'],
                   "application/octet-stream");
      assert.equal(res.data,
                   '\0' + "Some 16 bit text".split("").join("\0") + "\n");
    });
  });

  tr.addTest("text-file-post-8bit", () => {
    let ef = workingDir + "/transitory8";
    try {
      fs.unlinkSync(ef);
    } catch (e) {
			//console.debug(e);
		}

    return request.put(
			workingUrl + '/transitory8',
			"Some 8 bit text",
			{
				auth: { username: server_config.auth.user,
						    password: server_config.auth.pass },
				encoding: null
			})
    .then(res => {
      assert(fs.existsSync(ef));
      return request.get(workingUrl + '/transitory8', {
        auth: { username: server_config.auth.user,
                password: server_config.auth.pass },
        encoding: null,
      });
		})
    .then(res => {
      assert.equal(res.data, "Some 8 bit text");
      fs.unlinkSync(ef);
    });
  });

  tr.addTest("text-file-post-16bit", () => {
    let ef = workingDir + "/transitory16";
    try {
      fs.unlinkSync(ef);
    } catch (e) {
			//console.debug(e);
		}
    let text = "\0S\0o\0m\0e\0 \0" + "1\0" + "6\0 \0b\0i\0t\0 \0t\0e\0x\0t";

    return request.put(
			workingUrl + '/transitory16',
			text,
			{
				auth: { username: server_config.auth.user,
						    password: server_config.auth.pass },
				encoding: null
			})
		.then(res => {
      assert.equal(res.status, 200);
      assert(fs.existsSync(ef));
      return request.get(workingUrl + '/transitory16', {
        auth: { username: server_config.auth.user,
                password: server_config.auth.pass },
        encoding: null,
      });
		})
		.then(res => {
      assert.equal(res.status, 200);
      assert.equal(res.headers['content-type'], "application/octet-stream");
      assert.equal(res.data, text);
      fs.unlinkSync(ef);
    });
  });

  tr.addTest("bad-post", () => {
    return request.put(serverUrl + '/banished',
                       "Delete this file",
                       {
				                 auth: { username: server_config.auth.user,
						                     password: server_config.auth.pass },
				                 encoding: null
                       })
    .then(() => {
      assert(false, "Unexpected");
    })
    .catch(err => {
      assert.equal(err.response.status, 403);
      assert(!fs.existsSync(__dirname + "/banished"));
    });
  });

  // Make sure binary data works
  tr.addTest("binary-data", () => {
    let ef = workingDir + "/encrypted";
    try {
      fs.unlinkSync(ef);
    } catch (e) {
			//console.debug(e);
		}
    let text = "Alice, Bob, Charlie, and Doug";
    let pass = "password";
    return Cryptographer.encrypt(Utils.StringToUint8Array(text), pass)
		.then(cipherData => {
			return request.put(
			  workingUrl + '/encrypted',
			  cipherData,
			  {
				  auth: { username: server_config.auth.user,
						      password: server_config.auth.pass }
			  });
		})
		.then(() => assert(fs.existsSync(ef)))
    .then(() => request.get(workingUrl + '/encrypted', {
      auth: { username: server_config.auth.user,
              password: server_config.auth.pass
				    },
			responseType: 'arraybuffer',
      headers: {
        'Content-Type': 'application/octet-stream'
      }
    }))
		.then(res => {
			const cipherData = Uint8Array.from(res.data);
			return Cryptographer.decrypt(cipherData, pass);
		})
		.then(ab => {
			const plaintext = Utils.Uint8ArrayToString(ab);
      assert.equal(plaintext, text);
      fs.unlinkSync(ef);
    });
  });

  let server = new Server(server_config);
  server.start()
  .then(() => {
    return tr.run();
  })
  .then(() => {
    server.stop();
  });
});
