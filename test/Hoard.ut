/*@preserve Copyright (C) 2015-2019 Crawford Currie http://c-dot.co.uk license MIT*/
/*eslint-env shared-node-browser, mocha */

if (typeof requirejs === "undefined") {
    requirejs = require('requirejs');
	requirejs.config({
		baseUrl: `${__dirname}/..`
	});
}

requirejs(["js/Hoard", "js/Node", "js/Action", "test/TestRunner"], function(Hoard, Node, Action, TestRunner) {
    let tr = new TestRunner("Hoard");
    let assert = tr.assert;
    
	const cloud_actions = [
		// Action already in the client
		new Action({
			type: "N",
			time: Date.UTC(2000,0),
			path: ["FineDining"]
		}),
		// Action not in the client yet
		new Action({
			type: "N",
			time: Date.UTC(2002,0),
			path: [ "FineDining", "Caviar" ]
		})
	];

	// Client hoard, with populated cache and action stream
	const client_actions = [
		// Duplicate an action that is already in the cloud, different date
		new Action({
			type: "N",
			time: Date.UTC(2000,0,1),
			path: ["FineDining"]
		}),
		new Action({
			// Add an action that isn't in the cloud yet
			type: "N",
			time: Date.UTC(2003,0,1),
			path: ["FineDining", "Truffles" ],
			data: "Fungi"
		})
	];

    tr.addTest("should play_actions into empty hoard", function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
        let original = new Node(h.tree); // make copy
        assert(original);
        assert(!original.children);
        assert(original.time);
		for (let act of cloud_actions) {
			const played = [];
            let r = h.play_action(act, true, (act) => played.push(act));
            assert.deepEqual(r.action, act);
			assert.deepEqual(played, [act]);
            assert(!r.conflict);
		}
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2002,0),
					children:{
						Caviar: {
							time: Date.UTC(2002,0)
						}
					}
                }
            },
			// Touched at the time "FineDining" was stamped
			time: Date.UTC(2000,0)
		});
        assert.equal(h.history.length, 2);
    });

    tr.addTest("should play_actions into populated hoard", function() {
        let debug;// = console.debug;
		// Play the cloud action set into a populated client hoard
		var h = new Hoard({debug: debug});
		const conflicts = h.play_actions(client_actions);
		assert.equal(conflicts.length, 0);
		for (let act of cloud_actions) {
			let r = h.play_action(act, true);
            assert.deepEqual(r.action, act);
            if (act.path.length === 1) {
                assert(r.conflict);
                assert.equal(r.conflict, "Create FineDining failed: It was already created @ Wed Jan 01 2003 00:00:00 GMT+0000 (Greenwich Mean Time)");
            }
        }
		assert.deepEqual(h.tree, {
			children:{
				FineDining:{
					time:Date.UTC(2002,0),
					children:{
						Caviar:{
							time:Date.UTC(2002,0)
						},
						Truffles: {
							time: Date.UTC(2003,0),
							value: "Fungi"
						}
					}
				}
			},
			time: h.tree.time
		});
    });

    tr.addTest('should play_action N (node)', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
        let original = new Node(h.tree);
        let act = new Action({
			type: "N",
			time: Date.UTC(2002,0),
			path: [ "Lunch" ]
        });
        let c = h.play_action(act);
        assert(!c.conflict);
        assert.deepEqual(h.tree, {
            children: {
                Lunch: {
					time: Date.UTC(2002,0)
                }
            },
            time: Date.UTC(2002,0)
        });   
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "D");
        assert.deepEqual(h.history[0].undo.path, [ "Lunch" ]);
		assert(h.can_undo());
        c = h.undo();
        assert(!c.conflict);
        assert.equal(h.history.length, 0);
        // Replayed to empty tree
        assert.deepEqual(h.tree, original);
    });
    
    tr.addTest('should play_action N (leaf)', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
        let original = new Node(h.tree);
        let act = new Action({
			type: "N",
			time: Date.UTC(2002,0),
			path: [ "Lunch" ],
            data: "Sausages"
        });
        let c = h.play_action(act);
        assert(!c.conflict);
        assert.deepEqual(h.tree, {
            children: {
                Lunch: {
					time: Date.UTC(2002,0),
					value: "Sausages"
                }
            },
            time: Date.UTC(2002,0)
        });
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "D");
        assert.deepEqual(h.history[0].undo.path, [ "Lunch" ]);
		assert(h.can_undo());
        c = h.undo();
        assert.equal(h.history.length, 0);
        assert.deepEqual(h.tree, original);
    });

    tr.addTest('play_action N on leaf', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
        //let original = new Node(h.tree);
        let c = h.play_action(new Action({
			type: "N",
			time: Date.UTC(2002,0),
			path: [ "Lunch" ],
            data: "Sausages"
        }), false);
		
        assert(!c.conflict);
        c = h.play_action(new Action({
			type: "N",
			time: Date.UTC(2002,0),
			path: [ "Lunch", "Break" ],
            data: "Crisps"
        }));
        assert(!c.conflict);
        assert.deepEqual(h.tree, {
            children: {
                Lunch: {
					time: Date.UTC(2002,0),
					children: {
						Break: {
							time: Date.UTC(2002,0),
							value: "Crisps"
						}
					},
					value: "Sausages"
                }
            },
            time: Date.UTC(2002,0)
        });
    });

    tr.addTest("missing intermediates", async function() {
        let debug;// = console.debug;
        let h = new Hoard(debug);
		const acts = [
			new Action({
				type: "N",
				time: 500,
				path: [ "One", "Two", "Three" ],
				data: "Floop"
			})
		];
		const played = [];
        const conflicts = h.play_actions(acts, false, (act) => played.push(act));
		assert.equal(conflicts.length, 0);
		assert.deepEqual(played, [
			new Action( { type: 'N', path: [ 'One' ], time: 500 }),
			new Action( { type: 'N', path: [ 'One', 'Two' ], time: 500 }),
			new Action({
				type: 'N',
				path: [ 'One', 'Two', 'Three' ],
				time: 500,
				data: 'Floop'
			})
		]);
    });

    tr.addTest("missing leaf X+", async function() {
        let debug;// = console.debug;
        let h = new Hoard(debug);
		const acts = [
			new Action({
				type: "X",
				time: 500,
				path: [ "One", "Two", "Three" ],
				data: {
					size: 10,
					chars: "ABC"
				}
			})
		];
        const conflicts = h.play_actions(acts);
		assert.equal(conflicts.length, 0);
		assert(h.tree.getNodeAt([ "One", "Two", "Three" ]));
    });

    tr.addTest("missing leaf E", async function() {
        let debug;// = console.debug;
        let h = new Hoard(debug);
		const acts = [
			new Action({
				type: "E",
				time: 500,
				path: [ "One", "Two", "Three" ],
				data: "Smooch"
			})
		];
		const played = [];
        const conflicts = h.play_actions(acts, (act) => played.push(act));
		assert.equal(conflicts.length, 0);
		assert.deepEqual(played, [
			new Action( { type: 'N', path: [ 'One' ], time: 500 }),
			new Action( { type: 'N', path: [ 'One', 'Two' ], time: 500 }),
			new Action( {
				type: 'N',
				path: [ 'One', 'Two', 'Three' ],
				time: 500,
				data: 'PLACEHOLDER'
			}),
			new Action( {
				type: 'E',
				path: [ 'One', 'Two', 'Three' ],
				time: 500,
				data: 'Smooch'
			})
		]);
		assert(h.tree.getNodeAt([ "One", "Two", "Three" ]));
    });

    tr.addTest("missing leaf X-", async function() {
        let debug;// = console.debug;
        let h = new Hoard(debug);
		const acts = [
			new Action({
				type: "X",
				time: 500,
				path: [ "One", "Two", "Three" ]
				// data being nudefined should remove the constraint.
				// But since the leaf doesn't exist, this should be a NOP
			})
		];
        const conflicts = h.play_actions(acts);
		assert.equal(conflicts.length, 0);
		assert(!h.tree.getNodeAt([ "One", "Two", "Three" ]));
    });

    tr.addTest("missing leaf A+", async function() {
        let debug;// = console.debug;
        let h = new Hoard(debug);
		const acts = [
			new Action({
				type: "A",
				time: 500,
				path: [ "One", "Two", "Three" ],
				data: {
					due: 1000000
				}
			})
		];
        const conflicts = h.play_actions(acts);
		assert.equal(conflicts.length, 0);
		assert(h.tree.getNodeAt([ "One", "Two", "Three" ]));
    });

    tr.addTest("missing leaf A-", async function() {
        let debug;// = console.debug;
        let h = new Hoard(debug);
		const acts = [
			new Action({
				type: "A",
				time: 500,
				path: [ "One", "Two", "Three" ]
				// data being nudefined should remove the alarm.
				// But since the leaf doesn't exist, this should be a NOP
			})
		];
        const conflicts = h.play_actions(acts);
		assert.equal(conflicts.length, 0);
		assert(!h.tree.getNodeAt([ "One", "Two", "Three" ]));
    });

    tr.addTest('should play_action M', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of cloud_actions) {
			h.play_action(act, false);
        }
		h.play_action(new Action({
			type: "N",
			time: Date.UTC(2001,0,1),
			path: ["FineDining", "Roe" ],
        }), false);
		h.play_action(new Action({
			type: "N",
			time: Date.UTC(2003,0,1),
			path: ["FineDining", "Caviar", "Sevruga" ],
            data: "Meaty"
        }), false);
		h.play_action(new Action({
			type: "N",
			time: Date.UTC(2004,0,1),
			path: ["FineDining", "Caviar", "Beluga" ],
            data: "Fishy"
        }), false);

        let original = new Node(h.tree);
        
        // Move Beluga to be a subnode of Roe
        let act = new Action({
			type: "M",
			time: Date.UTC(2005,0),
			path: ["FineDining", "Caviar", "Beluga"],
            data: [ "FineDining", "Roe" ]
        });
		let r = h.play_action(act);
        assert(!r.conflict);
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "M");
        assert.deepEqual(h.history[0].undo.data, ["FineDining", "Caviar"]);
        assert.deepEqual(h.history[0].undo.path, ["FineDining", "Roe", "Beluga"]);
        assert.equal(h.history[0].undo.time, Date.UTC(2004,0));
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2001,0),
					children:{
						Caviar: {
							time: Date.UTC(2005,0),
							children: {
                                Sevruga: {
									time: Date.UTC(2003,0,1),
                                    value: "Meaty"
                                }
                            }
						},
                        Roe: {
							time: Date.UTC(2005,0),
                            children: {
                                Beluga: {
									time: Date.UTC(2004,0,1),
                                    value: "Fishy"
                                }
                            }
                        }
					}
                }
            },
            time: Date.UTC(2000,0)
        });
		assert(h.can_undo());
        r = h.undo();
        assert(!r.conflict);
        // The time for "Roe" will not be restored to the original
        // creation time, but will get the time on "Caviar"
        // - this is an accepted limitation of the move process, it's
        // not perfectly symmetrical
        original.getNodeAt('FineDining↘Roe').time
        = original.getNodeAt('FineDining↘Caviar').time;
		assert.deepEqual(h.tree, original);
    });

    tr.addTest('should play_action R', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of client_actions) {
			h.play_action(act, false);
        }

        let original = new Node(h.tree);

        let act = new Action({
			type: "R",
			time: Date.UTC(2005,0),
			path: ["FineDining", "Truffles"],
            data: "Earthball"
        });
		let r = h.play_action(act);
        assert(!r.conflict);
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2005,0),
					children:{
						Earthball: {
							time: Date.UTC(2003,0),
							value: "Fungi"
						}
					}
                }
            },
            time: Date.UTC(2000,0)
        });
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "R");
        assert.equal(h.history[0].undo.data, "Truffles");
        assert.deepEqual(h.history[0].undo.path, ["FineDining", "Earthball"]);
        assert.equal(h.history[0].undo.time, Date.UTC(2003,0,1));
		assert(h.can_undo());
        r = h.undo();
        assert(!r.conflict);
        assert.equal(h.history.length, 0);
		assert.deepEqual(h.tree, original);
    });

    tr.addTest('should play_action E', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of client_actions) {
			h.play_action(act, false);
        }

        let original = new Node(h.tree);

        let act = new Action({
			type: "E",
			time: Date.UTC(2005,0),
			path: ["FineDining", "Truffles"],
            data: "Earthball"
        });
		let r = h.play_action(act);
        assert(!r.conflict);
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2003,0,1),
					children:{
						Truffles: {
							time: Date.UTC(2005,0),
							value: "Earthball"
						}
					}
                }
            },
            time: Date.UTC(2000,0)
        });
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "E");
        assert.equal(h.history[0].undo.data, "Fungi");
        assert.deepEqual(h.history[0].undo.path, ["FineDining", "Truffles"]);
        assert.equal(h.history[0].undo.time, Date.UTC(2003,0,1));
		assert(h.can_undo());
        r = h.undo();
        assert(!r.conflict);
        assert.equal(h.history.length, 0);
		assert.deepEqual(h.tree, original);
    });

    tr.addTest('should play_action X', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of client_actions) {
			h.play_action(act, false);
        }
        let original = new Node(h.tree);
        let act = new Action({
			type: "X",
			time: Date.UTC(2005,0),
			path: ["FineDining", "Truffles"],
            data: { size: 1, chars: "2" }
        });
		let r = h.play_action(act);
        assert(!r.conflict);
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2003,0,1),
					children:{
						Truffles: {
							time: Date.UTC(2005,0),
							value: "Fungi",
                            constraints: { size: 1, chars: "2" }
						}
					}
                }
            },
            time: Date.UTC(2000,0)
        });
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "X");
        assert.isUndefined(h.history[0].undo.data);
        assert.deepEqual(h.history[0].undo.path, ["FineDining", "Truffles"]);
        assert.equal(h.history[0].undo.time, Date.UTC(2003,0,1));
		assert(h.can_undo());
        r = h.undo();
        assert(!r.conflict);
        assert.equal(h.history.length, 0);
		assert.deepEqual(h.tree, original);
    });

    tr.addTest('should play_action D/I', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of client_actions) {
			h.play_action(act, false);
        }
        let original = new Node(h.tree);
        let act = new Action({
			type: "D",
			time: Date.UTC(2005,0),
			path: ["FineDining", "Truffles"]
        });
		let r =  h.play_action(act);
        assert(!r.conflict);
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2005,0,1)
                }
            },
            time: Date.UTC(2000,0)
        });
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "I");
        assert.equal(typeof h.history[0].undo.data, "string");
        assert.deepEqual(h.history[0].undo.path, ["FineDining", "Truffles"]);
        assert.equal(h.history[0].undo.time, Date.UTC(2003,0,1));
		assert(h.can_undo());
        r = h.undo();
        assert(!r.conflict, r.conflict);
        assert.equal(h.history.length, 0);
		assert.deepEqual(h.tree, original);
    });

    tr.addTest('should play_action A/C', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of cloud_actions) {
			h.play_action(act, false);
        }
        let original = new Node(h.tree);
        let act = new Action({
			type: "A",
			time: Date.UTC(2005,0),
			path: ["FineDining", "Caviar"],
            data: 1
        });
		let r = h.play_action(act);
        assert(!r.conflict);
		assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2002,0),
					children:{
						Caviar: {
							time: Date.UTC(2005,0),
                            alarm: {
                                due: Date.UTC(2005,0,2),
                                repeat: 1 * 24 * 60 * 60 * 1000
                            }
						}
					}
                }
            },
            time: Date.UTC(2000,0)
        });
        assert.equal(h.history.length, 1);
        assert.deepEqual(h.history[0].redo, act);
        assert.equal(h.history[0].undo.type, "C");
        assert.deepEqual(h.history[0].undo.path, ["FineDining", "Caviar"]);
        assert.equal(h.history[0].undo.time, Date.UTC(2002,0));
		assert(h.can_undo());
        r = h.undo();
        assert(!r.conflict);
        assert.equal(h.history.length, 0);
		assert.deepEqual(h.tree, original);
    });

    tr.addTest('should make from actions', async function() {
        let debug;// = console.debug;
		var h = new Hoard({debug: debug});
		const conflicts = h.play_actions(cloud_actions);
		assert.equal(conflicts.length, 0);
        assert.deepEqual(h.tree, {
            children: {
                FineDining: {
					time: Date.UTC(2002,0),
					children:{
						Caviar: {
							time: Date.UTC(2002,0),
						}
					}
                }
            },
            // Touched at the time "FineDining" was stamped
            time: Date.UTC(2000,0)
        });
        assert.equal(h.history.length, 2);
    });

    tr.addTest('should make from hoard', async function() {
        let debug;// = console.debug;
        let h1 = new Hoard({debug: debug});
		const conflicts = h1.play_actions(client_actions);
		assert.equal(conflicts.length, 0);
        let h = new Hoard({hoard: h1, debug: debug});
        assert.deepEqual(h1, h);
    });

    tr.addTest('should create parent', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});
		for (let act of cloud_actions) {
			h.play_action(act);
        }
		let act = new Action({
			type: "N",
			time: Date.UTC(2004,0),
			path: ["Junk", "Burger"],
			data: "Mayo"
        });
        let r = h.play_action(act);
		assert(!r.conflict);
        assert.deepEqual(r.action, act);
		let leef = h.tree.getNodeAt(["Junk", "Burger"]);
		assert(leef instanceof Node);
		assert.equal(leef.value, "Mayo");
    });

    tr.addTest('should conflict: no such node (delete)', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});

		// No cache, so promise should be resolved will be called
		const c = h.play_action(new Action({
            type: "D",
            path: ["FineDining", "La Gavroche"]
        }));
        assert.equal(
            c.conflict,
            "Delete FineDining↘La Gavroche failed: it does not exist");
    });

    tr.addTest('should create node (edit)', function() {
        let debug;// = console.debug;
        let h = new Hoard({debug: debug});

        let kfc = new Action({
			type: "E",
			time: Date.UTC(2004,0),
			path: ["FineDining", "Doner"],
            data: "Sausages"
		});

		let e = h.play_action(cloud_actions[0]);
		assert.deepEqual(cloud_actions[0], e.action);
		h.play_action(kfc);
        e = h.play_action(kfc);
		assert(!e.conflict);
        assert.deepEqual(e.action, kfc);
		let node = h.tree.getNodeAt(["FineDining", "Doner"]);
		assert.equal(node.value, "Sausages");
    });

    tr.addTest("should ring alarms", async function() {
        let debug;// = console.debug;
        let actions = [
            new Action({
				type: "N",
				time: Date.UTC(2000,0),
				path: ["FineDining"]
            }),
            new Action({
				type: "A",
				time: Date.UTC(2007,0,30),
                data: 200, // should be interpreted as "200 days from
                // the time the alarm was added"
				path: [ "FineDining" ]
            }),
            new Action({
				type: "N",
				time: Date.UTC(2001,6,1),
				path: [ "FineDining", "Caviare" ]
            }),
            new Action({
				type: "N",
				time: Date.UTC(2002,0,1),
				path: [ "FineDining", "Caviare", "Beluga" ],
                data: "£6.70 per gram"
            }),
            new Action({
                type: "A",
				path: [ "FineDining", "Caviare", "Beluga" ],
				time: Date.UTC(2003,0,1),
                data: {
                    due: Date.UTC(2003,3,11),
                    repeat: 3600000000
                }
            })
        ];
		actions[1].ring_expected = Date.UTC(2007,7,18);
		actions[4].ring_expected = Date.UTC(2003,3,11);
		
        let cloud = new Hoard({debug: debug});
		const conflicts = cloud.play_actions(actions);
		assert.equal(conflicts.length, 0);
        return cloud.check_alarms(function(path, rang_at) {
            for (let a of actions) {
                if (a.type === "A" && TestRunner.samePath(a.path, path)) {
                    assert(!a.rung);
                    assert.equal(
                        rang_at.getTime(), a.ring_expected,
						
                        rang_at.toUTCString() + "!="
                        + new Date(a.ring_expected).toUTCString()
                        + " at " + path);
                    a.rung = true;
                }
            }
            return Promise.resolve();
        })
        .then(() => {
            for (let act of actions) {
                if (act.type === "A" && "ring_expected" in act)
                    assert(act.rung,
                           new Action(act).verbose()
                           + " did not ring at "
                           + new Date(act.ring_expected).toUTCString());
            }
            
            assert.equal(cloud.tree.getChild("FineDining").alarm.repeat,
                         17280000000);
            assert.equal(
                cloud.tree.getNodeAt("FineDining↘Caviare↘Beluga").alarm.repeat,
                3600000000);
        });
    });

    tr.addTest("get_node", function() {
        let debug;// = console.debug;
        const actions = [
            new Action({
				type: "N",
				time: Date.UTC(2000,0,1),
				path: ["A"]
            }),
            new Action({
				type: "N",
				time: Date.UTC(2001,6,1),
				path: [ "A", "A" ]
            }),
            new Action({
				type: "N",
				time: Date.UTC(2002,0,1),
				path: [ "A", "B" ]
            }),
            new Action({
				type: "N",
				time: Date.UTC(2002,0,1),
				path: [ "A", "C" ]
            }),
            new Action({
                type: "N",
				path: [ "A", "B", "C" ],
				time: Date.UTC(2003,0,1)
            }),
            new Action({
				type: "N",
				time: Date.UTC(2002,0,2),
				path: ["A", "C"]
            })
        ];
        let cloud = new Hoard({debug: debug});
		for (let act of actions) {
			cloud.play_action(act);
        }
        cloud.play_action(new Action({
			type: "N",
			time: Date.UTC(2001,6,1),
			path: [ "A", "A" ]
        }));
        let n = cloud.get_node(["A", "B", "C"]);
        assert.equal(n.time, Date.UTC(2003,0,1));
        n = cloud.get_node(["A", "A"]);
        assert.equal(n.time, Date.UTC(2001,6,1));
        n = cloud.get_node(["A", "B", "D"]);
        assert(!n);
    });

    const full_tree_actions = [
        new Action({
			type: "N",
			time: 100,
			path: ["FineDining"]
        }),
        new Action({
			type: "A",
			time: 200,
            data: { due: Date.UTC(2015,3,4), repeat: 10 },
			path: ["FineDining"]
        }),
        new Action({
			type: "N",
			time: 300,
			path: [ "FineDining", "Caviare" ]
        }),
        new Action({
			type: "N",
			time: 400,
			path: [ "FineDining", "Caviare", "Beluga" ],
            data: "£6.70 per gram"
        }),
        new Action({
            type: "A",
			path: [ "FineDining", "Caviare", "Beluga" ],
			time: 500,
            data: {
                due: Date.UTC(2007,11,25),
                repeat: 100
            }
        }),
        new Action({
            type: "A",
			path: [ "FineDining", "Caviare" ],
			time: 600,
            data: {
                due: Date.UTC(2005,3,1),
                repeat: 365}
        }),
        new Action({
			type: "X",
			time: 300,
			path: [ "FineDining", "Caviare", "Beluga" ],
            data: { size: 32, chars: "A-Z;0-9" }
        })
    ];

    let full_tree_json = {
        FineDining: {
            time: 300,
            children: {
                Caviare: {
                    time: 600,
                    children: {
                        Beluga: {
                            time: 300,
                            value: "£6.70 per gram",
                            alarm: {
                                due: Date.UTC(2007,11,25),
                                repeat: 100
                            },
                            constraints: { size: 32, chars: "A-Z;0-9" }
                        }
                    },
                    alarm: {
                        due: Date.UTC(2005,3,1),
                        repeat: 365
                    }
                }
            },
            alarm: {
                due: Date.UTC(2015,3,4), repeat: 10
            }
        }
    };

    tr.addTest("actions from tree", async function() {
        let debug;// = console.debug;
        let cloud = new Hoard({debug: debug});
		const conflicts = cloud.play_actions(full_tree_actions);
		assert.equal(conflicts.length, 0);

        // Make sure we can construct from the tree
		let h = new Hoard({debug: debug, tree: cloud.tree});
        assert.deepEqual(h.tree, cloud.tree);
		
        let acts = cloud.actions_to_recreate();
        assert.deepEqual(acts, [
            { type: 'N', path: [ 'FineDining' ],
              time: 300 }, // creation of 'Caviare',
            { type: 'A', path: [ 'FineDining' ],
              time: 300,
              data: {
                  due: Date.UTC(2015,3,4), repeat: 10
              }},
            { type: 'N', path: [ 'FineDining', 'Caviare' ],
              time: 600 }, // alarm
            { type: 'A', path: [ 'FineDining', 'Caviare' ],
              time: 600,
              data: {
                  due: Date.UTC(2005,3,1),
                  repeat: 365
              }},
            { type: 'N', path: [ 'FineDining', 'Caviare', 'Beluga' ],
              time: 300,
              data: '£6.70 per gram' },
            { type: 'A', path: [ 'FineDining', 'Caviare', 'Beluga' ],
              time: 300,
              data: {
                  due: Date.UTC(2007,11,25),
                  repeat: 100
              }},
            { type: 'X', path: [ 'FineDining', 'Caviare', 'Beluga' ],
              time: 300,
              data: { size: 32, chars:"A-Z;0-9" }
            }
        ]);
    });

    tr.run();
});
